#!/usr/bin/env ruby

require 'open3'
require 'json'

eval File.read('spell.rb', encoding: 'UTF-8')

check :html5 do
  cmd = 'java -jar vendor/vnu.jar --format json --skip-non-html output/'
  res = Open3.popen3(cmd) { |_stdin, _stdout, stderr| stderr.read }

  JSON.parse(res).fetch('messages', []).each do |err|
    subject = err['url'].sub(/^file:#{Regexp.escape File.dirname(__FILE__)}\//, '')
    add_issue("#{err['message']} (line #{err['lastLine']}, column #{err['firstColumn']})", subject: subject)
  end
end

check :no_unprocessed_erb do
  self.output_filenames.each do |fn|
    if fn =~ /html$/ && File.read(fn).match(/<%/)
      self.add_issue("erb detected", :subject => fn)
    end
  end
end

check :no_markdown_links_in_output do
  self.output_filenames.each do |fn|
    if fn =~ /html$/ && File.read(fn).match(/]\(/)
      self.add_issue("unprocessed Markdown detected", :subject => fn)
    end
  end
end

check :valid_sitemap do
  require 'nokogiri'

  xsd = Nokogiri::XML::Schema(File.read('misc/sitemap.xsd'))
  doc = Nokogiri::XML(File.read('output/sitemap.xml'))

  unless xsd.valid?(doc)
    self.add_issue("sitemap does not adhere to XML schema", :subject => 'output/sitemap.xml')
  end
end

check :no_smartness_in_kbd do
  self.output_filenames.each do |fn|
    if fn =~ /html$/ && File.read(fn).match(/<kbd>[^<]*[–—][^<]*<\/kbd>/)
      self.add_issue("smartness in kbd elem detected", :subject => fn)
    end
  end
end

check :spelling do
  acceptable_words = Set.new(File.readlines('acceptable_words.txt').map(&:strip))

  acceptable_files = [
    # These are auto-generated from Nanoc’s API documentation. Fixing these is a task for later.
    'output/doc/reference/commands/index.html',

    # The release notes contain lots of old, write-once, unmaintained content. Fixing these is a task for later.
    'output/release-notes/details/index.html',

    # The style guide uses nonsensical text.
    'output/style-guide/index.html',
  ]

  checker = NanocSpellChecker.new(acceptable_words, Dir.glob('output/**/*.html') - acceptable_files)

  misspelled_words = checker.run

  misspelled_words.keys.sort.each do |key|
    next if acceptable_files.include?(key)

    misspelled_words[key].each do |value|
      self.add_issue("misspelled word: #{value}", subject: key)
    end
  end
end

deploy_check :ilinks
deploy_check :stale
deploy_check :no_unprocessed_erb
deploy_check :no_markdown_links_in_output
deploy_check :valid_sitemap
deploy_check :no_smartness_in_kbd
deploy_check :spelling
deploy_check :mixed_content
