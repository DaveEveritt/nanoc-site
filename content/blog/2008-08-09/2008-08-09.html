<div style="margin: 1.8em 0; text-align: center;">
	<img src="/assets/images/whats-new-in-nanoc-21-small.png" alt="What's New in nanoc 2.1">
</div>

<p>Welcome to installment #5 of What's New in nanoc 2.1. This article will show you two of the biggest new features of nanoc 2.1: <em>asset compilation</em> and <em>multiple representations</em>.</p>

<p>The new <strong>asset compilation</strong> feature allows a site to have assets, which can be run through filters. Assets can be anything&mdash;<a href="http://haml.hamptoncatlin.com/docs/rdoc/classes/Sass.html">Sass</a> stylesheets, images, MP3s, videos, and so on. Filters can then compile Sass, rescale images, make images grayscale, change the volume of a MP3 file, play a video backwards (so you get to see the end first), etc. The only limit is your imagination.</p>

<p>nanoc supports two different kinds of assets: <em>textual</em> and <em>binary</em> assets. Textual assets will be compiled by textual filters, which are the filters you already know. An example of a textual asset would be a Sass stylesheet. Binary assets are all assets that aren't text. Examples of binary assets include images, sound and music files, videos, etc.</p>

<p>Binary assets require a <strong>new kind of filters called binary filters</strong>. Binary filters, unlike textual filters, do not load assets into memory. This means binary assets can be arbitrarily big.</p>

<p>So how does nanoc handle assets? If you are using the filesystem data source, you can create a directory aptly named <span class="path">assets</span> in your site directory, in which you put your assets. Assets are directories containing the actual asset file and a meta file, exactly like pages.</p>

<p>For example, the nanoc site has an asset named "style", whose directory contains "style.css" and "style.yaml". The attributes in the meta file look like this:</p>

<pre><code><span class="attribute">binary</span>:  <span class="value">false</span>
<span class="attribute">filters</span>: []</code></pre>

<p>There are only two built-in asset attributes. <code>binary</code> indicates whether the asset is binary or not (in this case it is a textual asset, thus <code>false</code>) and <code>filters</code> is the list of filters to run (empty, in this case).</p>

<p>If the stylesheet had been a Sass one, the attributes would have looked like this:</p>

<pre><code><span class="attribute">binary</span>:  <span class="value">false</span>
<span class="attribute">filters</span>: [ <span class="string">'sass'</span> ]</code></pre>

<p>&hellip; which should not be a big surprise.</p>

<p>Textual filters are exactly the same as the filters in nanoc 2.0, so there's probably not much point in showing one, but I'll just do it anyway:</p>

<pre><code><span class="keyword">class</span> <span class="storage">Sass</span> &lt; <span class="storage">Nanoc</span>::<span class="storage">Filter</span>

  <span class="function">identifier</span> <span class="symbol">:sass</span>

  <span class="keyword">def</span> <span class="function">run</span>(<span class="variable">content</span>)
    <span class="function">require</span> <span class="string">'sass'</span>

    ::<span class="storage">Sass</span>::<span class="storage">Engine</span>.<span class="function">new</span>(<span class="variable">content</span>).<span class="function">render</span>
  <span class="keyword">end</span>

<span class="keyword">end</span></code></pre>

<p>Binary assets are very similar to textual assets. Simply set <code>binary</code> to <code>true</code> in the meta file and make sure that the list of filters contains only binary filters.</p>

<p>Filters for binary assets are slightly different from textual filters. Firstly, binary filters inherit from <code>Nanoc::BinaryFilter</code> instead of <code>Nanoc::Filter</code>. Secondly, their <code>run</code> method takes a File object and not a string containing the asset content. Additionally, binary filters should return a File object representing the processed file. The original File argument should not be modified (otherwise you'd lose the original asset).</p>

<p>For example, a binary filter for generating a thumbnail of an image (using <a href="http://seattlerb.rubyforge.org/ImageScience.html">ImageScience</a>) could look like this (the code is non-functional, because the filter has a lot of irrelevant implementation details):</p>

<pre><code><span class="keyword">class</span> <span class="storage">ImageScienceThumbnail</span> &lt; <span class="storage">Nanoc</span>::<span class="storage">BinaryFilter</span>

  <span class="function">identifier</span> <span class="symbol">:image_science_thumbnail</span>

  <span class="keyword">def</span> <span class="function">run</span>(<span class="variable">file</span>)
    <span class="function">require</span> <span class="string">'image_science'</span>

    <span class="comment"># Get temporary path</span>
    <span class="variable">tmp_path</span> = ...

    <span class="comment"># Create thumbnail and write it to the temp path</span>
    ...

    <span class="comment"># Return thumbnail file</span>
    <span class="storage">File</span>.<span class="function">open</span>(<span class="variable">tmp_path</span>)
  <span class="keyword">end</span>

<span class="keyword">end</span></code></pre>

<p>The default router (see the <a href="/blog/2008-07-23/">article on routers</a>) saves compiled assets in an <span class="path">assets</span> directory inside the output directory. It's possible to set <var>assets_prefix</var> in the config file to something else such as "/media", or even "" to save assets directly in the output directory.</p>

<p>Now you know how to compile assets.</p>

<p>There is one small issue, though. Generating thumbnails of images is fine, but what if you want to keep the full-size version? There's not much point in only having a thumbnail, and not being able to show the full-size image.</p>

<p>This is where <strong>multiple representations</strong> come into play. A single asset can have different representations (or "reps"): a thumbnail rep, a grayscale rep, a full-size rep, &hellip; Even pages can have multiple reps.</p>

<p>Giving an asset multiple representations is quite easy. In the asset's meta file, fill up the list of reps like in this example:</p>

<pre><code><span class="attribute">reps</span>:
  <span class="attribute">default</span>:
    <span class="attribute">filters</span>:        []
  <span class="attribute">thumbnail</span>:
    <span class="attribute">filters</span>:        [ <span class="string">'image_science_thumbnail'</span> ]
    <span class="attribute">thumbnail_size</span>: <span class="constant">100</span></code></pre>

<p>The asset in this example has two representations: a default one (which is unprocessed) and a thumbnail one (which is run through the <code>image_science_thumbnail</code> filter).</p>

<p>Each representation has its own output file. The name of the output file is determined by the router. The default router appends the representation name to the filename.</p>

<p><a href="#">Last time</a> I wasn't able to show you what a real router looks like (because I didn't explain multiple representations before), but now I can. Let me just show you the implementation for <code>path_for_asset_rep</code> real quick:</p>

<pre><code><span class="keyword">def</span> <span class="function">path_for_asset_rep</span>(<span class="variable">asset_rep</span>)
  <span class="comment"># Get data we need</span>
  <span class="variable">extension</span>     = <span class="variable">asset_rep</span>.<span class="function">attribute_named</span>(<span class="symbol">:extension</span>)
  <span class="variable">modified_path</span> = <span class="variable">asset_rep</span>.<span class="function">asset</span>.<span class="function">path</span>[<span class="constant">0</span>..<span class="constant">-2</span>]
  <span class="variable">version</span>       = <span class="variable">asset_rep</span>.<span class="function">attribute_named</span>(<span class="symbol">:version</span>)

  <span class="comment"># Initialize path</span>
  <span class="variable">assets_prefix</span> = <span class="variable">@site</span>.<span class="function">config</span>[<span class="symbol">:assets_prefix</span>] || <span class="string">'/assets'</span>
  <span class="variable">path</span> = <span class="variable">assets_prefix</span> + <span class="variable">modified_path</span>

  <span class="comment"># Add rep name if necessary</span>
  <span class="keyword">unless</span> <span class="variable">asset_rep</span>.<span class="function">name</span> == <span class="symbol">:default</span>
    <span class="variable">path</span> += <span class="string">'-'</span> + <span class="variable">asset_rep</span>.<span class="function">name</span>.<span class="function">to_s</span>
  <span class="keyword">end</span>

  <span class="comment"># Add extension</span>
  <span class="variable">path</span> += <span class="string">'.'</span> + <span class="variable">extension</span>

  <span class="comment"># Done</span>
  <span class="variable">path</span>
<span class="keyword">end</span></code></pre>

<p>The implementation of <code>path_for_page_rep</code> is very similar, so I'm not showing it here.</p>

<p>The code should be fairly self-explanatory (the <code>[0..-2]</code> is used to strip off the trailing slash). The most important point is that routers determine paths of asset/page <em>representations</em> instead of paths of assets/pages.</p>

<p>So, that's what asset compilation and multiple representations look like. The end of the <i>What's New In nanoc 2.1</i> series is coming closer, but there is still one more installment to go. The last article in the series will discuss several minor new features and changes. Stay tuned!</p>
