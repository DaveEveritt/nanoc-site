<h2><span>Help &raquo; Manual &raquo;<br>Chapter 3: Extending nanoc</span></h2>

<p><a href="/help/manual/">&laquo; Back to the Manual Table of Contents</a></p>

<p>nanoc 2.0 is quite customizable. Apart from being able to write arbitrary code that is executed before a site is compiled, it is also possible to write custom filters, data sources and layout processors.</p>

<div class="section" id="writing-data-sources">
	<h3><span>Writing Data Sources</span></h3>

	<p>A data source is responsible for loading a site's data: pages, page defaults, templates, layouts and code. Perhaps surprisingly, it is also responsible for creating pages, layouts and templates.</p>

	<p>Data sources are classes that inherit from <code>Nanoc::DataSource</code>. There is no need to explicitly register data source classes; nanoc will find all data source classes automatically. It's like magic.</p>

	<p>Each data source has an identifier. This is a unique name that is used in a site's configuration file to specify which data source should be used to fetch data. It is specified like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">SampleDataSource</span> &lt; <span class="storage">Nanoc::DataSource</span>
 <span class="function">identifier</span> <span class="symbol">:sample</span>
<span class="keyword">end</span></code></pre>

	<p>All methods in the data source have access to the <code>@site</code> object, which represents the site. Probably the only very useful thing that can be done with this is request the configuration hash, using <code>@site.config</code>.</p>

	<div class="section" id="writing-data-sources-preparation">
		<h4><span>Preparation</span></h4>

		<p>There are two methods you may want to implement first: <code>up</code> and <code>down</code>. <code>up</code> is executed when the data source is loaded. For example, this would be the ideal place to establish a connection to the database. <code>down</code> is executed when the data source is unloaded, so this is the ideal place to undo what <code>up</code> did.</p>

		<p>The <code>setup</code> method is used to create the initial site structure. For example, a database data source could create the database and the necessary tables here.</p>

		<p>None of these three methods need to be implemented; you can simply leave the method definitions out.</p>
	</div>

	<div class="section" id="writing-data-sources-loading-data">
		<h4><span>Loading Data</span></h4>

		<p>The five methods that need to be implemented to load data are <code>pages</code>, <code>page_defaults</code>, <code>layouts</code>, <code>templates</code> and <code>code</code>. All these functions require an implementation.</p>

		<p>The <code>pages</code> function should return an array of hashes representing pages. These hashes must at least have two keys: <code>:uncompiled_content</code> and <code>:path</code>. These hashes can have additional keys for additional metadata. Example:</p>

		<pre><code><span class="keyword">def</span> <span class="function">pages</span>
 [
   { <span class="symbol">:uncompiled_content</span> => <span class="string">'Hi!'</span>,          <span class="symbol">:path</span> => <span class="string">'/'</span>       },
   { <span class="symbol">:uncompiled_content</span> => <span class="string">'Hello there.'</span>, <span class="symbol">:path</span> => <span class="string">'/about/'</span> }
 ]
<span class="keyword">end</span></code></pre>

		<p>The <code>page_defaults</code> function should return a hash with default values for page metadata. Example:</p>

		<pre><code><span class="keyword">def</span> <span class="function">page_defaults</span>
 { <span class="symbol">:layout</span> => <span class="string">'quux'</span> }
<span class="keyword">end</span></code></pre>

		<p><code>layouts</code> should return an array of hashes that represent layouts. Each has must have the <code>:name</code>, <code>:content</code> and <code>:extension</code> keys. <code>:extension</code> determines the layout processor that will be used for this page. For example:</p>

		<pre><code><span class="keyword">def</span> <span class="function">layouts</span>
 [
   {
     <span class="symbol">:name</span>       => <span class="string">'quux'</span>,
     <span class="symbol">:content</span>    => <span class="string">"&lt;html&gt;\n"</span> +
                    <span class="string">"  &lt;head&gt;\n"</span> +
                    <span class="string">"    &lt;title&gt;&lt;%= @page.title %&gt;&lt;/title&gt;\n"</span> +
                    <span class="string">"  &lt;/head&gt;\n"</span> +
                    <span class="string">"  &lt;body&gt;\n"</span> +
                    <span class="string">"&lt;%= @page.content %&gt;\n"</span> +
                    <span class="string">"  &lt;/body&gt;\n"</span> +
                    <span class="string">"&lt;/html&gt;"</span>,
     <span class="symbol">:extension</span>  => <span class="string">'.erb'</span>
   }
 ]
<span class="keyword">end</span></code></pre>

		<p><code>templates</code> should return an array of hashes that represent page templates. These page templates are used used by the <code>create_page</code> function (see next section) to create pages using a template. Each hash must have the <code>:name</code> key for identifying the template. Apart from that, the hash can be structured in any way. I recommend having <code>:content</code> (for the page content) and <code>:meta</code> (for the page metadata) keys. Just make sure that what <code>templates</code> serves is what <code>create_page</code> expects. For example:</p>

		<pre><code><span class="keyword">def</span> <span class="function">templates</span>
 [
   {
     <span class="symbol">:name</span>     => <span class="string">'default'</span>,
     <span class="symbol">:content</span>  => <span class="string">'Hi, I am a new page. Please edit me!'</span>,
     <span class="symbol">:meta</span>     => { <span class="symbol">:title</span> => <span class="string">'A New Page'</span> }
   }
 ]
<span class="keyword">end</span></code></pre>

		<p><code>code</code> should return a string containing the code that will be loaded right before the site is compiled. For example:</p>

		<pre><code><span class="keyword">def</span> <span class="function">code</span>
 <span class="string">"def foo ; 'bar' ; end"</span>
<span class="keyword">end</span></code></pre>
	</div>

	<div class="section" id="writing-data-sources-creating-data">
		<h4><span>Creating Data</span></h4>

		<p>Three methods that create data need to be implemented: <code>create_page</code>, <code>create_layout</code> and <code>create_template</code>. All these three methods require an implementation.</p>

		<p><code>create_page</code> is used for creating a new page using a given template. It has two arguments: the page path, and the template, which is a hash from the array of templates as returned by the <code>templates</code> function.</p>

		<p><code>create_layout</code> is used for creating a new layout. It has one argument: the layout name.</p>

		<p><code>create_template</code> is used for creating a new template. It has one argument: the template name.</p>
	</div>
</div>

<div class="section" id="writing-filters">
	<h3><span>Writing Filters</span></h3>

	<p>Filters are classes that inherit from <code>Nanoc::Filter</code>. Unlike with nanoc 1.x, they do not need to be explicitly registered; nanoc will find filter classes automatically.</p>

	<p>A filter has an identifier, which is an unique name that is used in a page's list of filters. It is set like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">CensorFilter</span> &lt; <span class="storage">Nanoc::Filter</span>
 <span class="function">identifier</span> <span class="symbol">:censor</span>
<span class="keyword">end</span></code></pre>

	<p>A filter can have multiple identifiers. For example, the Markdown filter is both identified as <code>markdown</code> and <code>bluecloth</code>. Specify multiple identifiers using <code>identifiers</code> instead of <code>identifier</code>, like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">CensorFilter</span> &lt; <span class="storage">Nanoc::Filter</span>
 <span class="function">identifiers</span> <span class="symbol">:censor</span>, <span class="symbol">:stop_the_hate</span>
<span class="keyword">end</span></code></pre>

	<p>A filter needs to implement only one method, <code>run</code>. This method takes the unfiltered content as its only argument, and returns the filtered content. For example:</p>

	<pre><code><span class="keyword">def</span> <span class="function">run</span>(<span class="variable">content</span>)
 <span class="variable">content</span>.<span class="function">gsub</span>(<span class="string">'nanoc sucks'</span>, <span class="string">'nanoc rocks'</span>)
<span class="keyword">end</span></code></pre>

	<p>The filter has access to several useful instance variables: <code>@page</code>, <code>@pages</code> and <code>@config</code>.</p>
</div>

<div class="section" id="writing-layout-processors">
	<h3><span>Writing Layout Processors</span></h3>

	<p>Layout processors are classes that inherit from <code>Nanoc::LayoutProcessor</code>. These classes do not need to be explicitly registered, as nanoc will find all layout processors automatically.</p>

	<p>A layout processor has an identifier and an extension. The identifier is currently not used; the extension determines what kind of files this layout processor applies to. They are specified like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">SampleLayoutProcessor</span> &lt; <span class="storage">Nanoc::LayoutProcessor</span>
 <span class="function">identifier</span> <span class="symbol">:sample</span>
 <span class="function">extension</span>  <span class="string">'.sample'</span>
<span class="keyword">end</span></code></pre>

	<p>It is also possible to use <code>identifiers</code> and <code>extensions</code> (with an extra s) instead.</p>

	<p>Layout processors only need to have the <code>run</code> method implemented, which takes the layout as its only argument, and returns the laid out page content. When laying out the page, the <code>@page</code>, <code>@pages</code> and <code>@config</code> objects should be made public. As an example, here's Markaby's <code>run</code> method:</p>

	<pre><code><span class="keyword">def</span> <span class="function">run</span>(<span class="symbol">layout</span>)
 <span class="function">nanoc_require</span> <span class="symbol">'markaby'</span>

 <span class="variable">assigns</span> = { <span class="symbol">:page</span> => <span class="variable">@page</span>, <span class="symbol">:pages</span> => <span class="variable">@pages</span>, <span class="symbol">:config</span> => <span class="variable">@config</span> }
 <span class="storage">Markaby</span>::<span class="storage">Builder</span>.<span class="function">new</span>(<span class="variable">assigns</span>).<span class="function">instance_eval</span>(<span class="variable">layout</span>).<span class="function">to_s</span>
<span class="keyword">end</span></code></pre>

	<p>In order for the <code>render</code> method (which is used to render sub-layouts) to work, it is also recommended to make the <code>@site</code> variable available in the layout.</p>
</div>
