<h2><span>Help &raquo; Manual &raquo;<br>Chapter 3: Extending nanoc</span></h2>

<p><a href="/help/manual/">&laquo; Back to the Manual Table of Contents</a></p>

<p>nanoc is quite customizable. Apart from being able to write arbitrary code that is executed before a site is compiled, it is also possible to write custom (binary) filters, data sources and routers.</p>

<div class="section" id="writing-data-sources">
	<h3><span>Writing Data Sources</span></h3>

	<p>A data source is responsible for loading and storing a site's data: pages, page defaults, assets, asset defaults, templates, layouts and code.</p>

	<p>Data sources are classes that inherit from <code>Nanoc::DataSource</code>. There is no need to explicitly register data source classes; nanoc will find all data source classes automatically.</p>

	<p>Each data source has an identifier. This is a unique name that is used in a site's configuration file to specify which data source should be used to fetch data. It is specified like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">SampleDataSource</span> &lt; <span class="storage">Nanoc::DataSource</span>
  <span class="function">identifier</span> <span class="symbol">:sample</span>
<span class="keyword">end</span></code></pre>

	<p>All methods in the data source have access to the <code>@site</code> object, which represents the site. One useful thing that can be done with this is request the configuration hash, using <code>@site.config</code>.</p>

	<div class="section" id="writing-data-sources-preparation">
		<h4><span>Preparation</span></h4>

		<p>There are two methods you may want to implement first: <code>up</code> and <code>down</code>. <code>up</code> is executed when the data source is loaded. For example, this would be the ideal place to establish a connection to the database. <code>down</code> is executed when the data source is unloaded, so this is the ideal place to undo what <code>up</code> did.</p>

		<p>The <code>setup</code> method is used to create the initial site structure. For example, a database data source could create the necessary tables here. The <code>destroy</code> method should do the opposite of what <code>setup</code> does. For example, a database data source would drop the created tables in this method.</p>

		<p>The <code>update</code> method is used for updating the format in which the data is stored. For example, a database data source could add necessary new columns here.</p>

		<p>None of these methods need to be implemented; you can simply leave the method definitions out.</p>
	</div>

	<div class="section" id="writing-data-sources-functions">
		<h4><span>Functions</span></h4>

		<p>The following methods (grouped by data type) are required to be implemented by any data source:</p>

		<dl class="nested">
			<dt>Pages &mdash; <code>Nanoc::Page</code></dt>
			<dd>
				<ul>
					<li><code>pages()</code></li>
					<li><code>save_page(page)</code></li>
					<li><code>move_page(page, new_path)</code></li>
					<li><code>destroy_page(page)</code></li>
				</ul>
			</dd>
			<dt>Page Defaults (singular) &mdash; <code>Nanoc::PageDefaults</code></dt>
			<dd>
				<ul>
					<li><code>page_defaults()</code></li>
					<li><code>save_page_defaults(page_defaults)</code></li>
				</ul>
			</dd>
			<dt>Assets &mdash; <code>Nanoc::Asset</code></dt>
			<dd>
				<ul>
					<li><code>assets()</code></li>
					<li><code>save_asset(asset)</code></li>
					<li><code>move_asset(asset, new_path)</code></li>
					<li><code>destroy_asset(asset)</code></li>
				</ul>
			</dd>
			<dt>Asset Defaults (singular) &mdash; <code>Nanoc::AssetDefaults</code></dt>
			<dd>
				<ul>
					<li><code>asset_defaults()</code></li>
					<li><code>save_asset_defaults(asset_defaults)</code></li>
				</ul>
			</dd>
			<dt>Layouts &mdash; <code>Nanoc::AssetDefaults</code></dt>
			<dd>
				<ul>
					<li><code>layouts()</code></li>
					<li><code>save_layout(layout)</code></li>
					<li><code>move_layout(layout, new_path)</code></li>
					<li><code>destroy_layout(layout)</code></li>
				</ul>
			</dd>
			<dt>Templates &mdash; <code>Nanoc::Template</code></dt>
			<dd>
				<ul>
					<li><code>templates()</code></li>
					<li><code>save_template(template)</code></li>
					<li><code>move_template(template, new_path)</code></li>
					<li><code>destroy_template(template)</code></li>
				</ul>
			</dd>
			<dt>Code (singular) &mdash; <code>Nanoc::Code</code></dt>
			<dd>
				<ul>
					<li><code>code()</code></li>
					<li><code>save_code(code)</code></li>
				</ul>
			</dd>
		</dl>

		<p>The "singular" indicates that there is only one resource of the specified kind. Such resources therefore lack <code>move_x</code> and <code>destroy_x</code> functions, as they cannot be moved nor destroyed.</p>

		<p>The class name next to each data type is the object type that is passed to functions or is returned from functions. For example, the <code>save_page</code> function will get a <code>Nanoc::Page</code> while the <code>layouts</code> function will return an array of <code>Nanoc::Layout</code>s.</p>

		<p>The loading functions (<code>pages</code>, <code>page_defaults</code>, &hellip;) should return an array of objects, or, if the resource is singular, a single object. These functions do not take any parameters.</p>

		<p>The saving functions (<code>save_page</code>, <code>save_page_defaults</code>, &hellip;) should store the given object. The argument is the object to be stored.</p>

		<p>The moving functions (<code>move_page</code>, &hellip;) should change the given object's name or path. The first argument is the object to be moved, while the second argument is the new path or new name.</p>

		<p>The destroying functions (<code>destroy_page</code>, &hellip;) should delete the given object. The argument is the object to be destroyed.</p>

		<p>If all this sounds a bit vague and weird, do check out the source of a data source, and the documentation of <code>Nanoc::DataSource</code> itself. The code is well-documented and should help you to get started quickly.</p>
	</div>
</div>

<div class="section" id="writing-filters">
	<h3><span>Writing Filters</span></h3>

	<p>Filters are classes that inherit from <code>Nanoc::Filter</code>. They do not need to be explicitly registered; nanoc will find filter classes automatically.</p>

	<p>A filter has an identifier, which is an unique name that is used in a page's list of filters. It is set like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">CensorFilter</span> &lt; <span class="storage">Nanoc::Filter</span>
  <span class="function">identifier</span> <span class="symbol">:censor</span>
<span class="keyword">end</span></code></pre>

	<p>A filter can have multiple identifiers. Specify multiple identifiers using <code>identifiers</code> instead of <code>identifier</code>, like this:</p>

	<pre><code><span class="keyword">class</span> <span class="storage">CensorFilter</span> &lt; <span class="storage">Nanoc::Filter</span>
  <span class="function">identifiers</span> <span class="symbol">:censor</span>, <span class="symbol">:stop_the_hate</span>
<span class="keyword">end</span></code></pre>

	<p>A filter needs to implement only one method, <code>run</code>. This method takes the unfiltered content as its only argument, and returns the filtered content. For example:</p>

	<pre><code><span class="keyword">def</span> <span class="function">run</span>(<span class="variable">content</span>)
  <span class="variable">content</span>.<span class="function">gsub</span>(<span class="string">'nanoc sucks'</span>, <span class="string">'nanoc rocks'</span>)
<span class="keyword">end</span></code></pre>

	<p>The filter has access to several useful instance variables:</p>
	
	<dl>
		<dt><code>@page_rep</code></dt>
		<dd>Contains the page representation that is being filtered.</dd>

		<dt><code>@page</code></dt>
		<dd>Contains the current page.</dd>

		<dt><code>@asset_rep</code></dt>
		<dd>Contains the asset representation that is being filtered.</dd>

		<dt><code>@asset</code></dt>
		<dd>Contains the current asset.</dd>

		<dt><code>@site</code></dt>
		<dd>Contains the site.</dd>
	</dl>
</div>

<div class="section" id="writing-binary-filters">
	<h3><span>Writing Binary Filters</span></h3>

	<p><strong>TODO write me</strong></p>
</div>

<div class="section" id="writing-layout-processors">
	<h3><span>Writing Layout Processors</span></h3>

	<p>As of nanoc 2.1, layout processors are filters, so there is no need to write separate layout processorsâ€”simply write a filter and use that one.</p>
</div>
